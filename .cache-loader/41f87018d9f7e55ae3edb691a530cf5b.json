{"remainingRequest":"/Users/eve/development/reaction/node_modules/babel-loader/lib/index.js??ref--6-1!/Users/eve/development/reaction/src/Router/PreloadLink.tsx","dependencies":[{"path":"/Users/eve/development/reaction/src/Router/PreloadLink.tsx","mtime":1534252031000},{"path":"/Users/eve/development/reaction/.babelrc","mtime":1532461619000},{"path":"/Users/eve/development/reaction/node_modules/cache-loader/dist/cjs.js","mtime":0},{"path":"/Users/eve/development/reaction/node_modules/babel-loader/lib/index.js","mtime":1509489566000}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PreloadLink = void 0;\n\nvar _pick2 = _interopRequireDefault(require(\"lodash/fp/pick\"));\n\nvar _last2 = _interopRequireDefault(require(\"lodash/fp/last\"));\n\nvar _isUndefined2 = _interopRequireDefault(require(\"lodash/fp/isUndefined\"));\n\nvar _isEmpty2 = _interopRequireDefault(require(\"lodash/fp/isEmpty\"));\n\nvar Found = _interopRequireWildcard(require(\"found\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _reactRelay = require(\"react-relay\");\n\nvar _state = require(\"./state\");\n\nvar _unstated = require(\"unstated\");\n\nvar _Artsy = require(\"../Components/Artsy\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar _PreloadLink = function _PreloadLink(preloadLinkProps) {\n  /**\n   * Create a Preloader wrapper to perform relay fetches and render out a <Link>\n   */\n  var Preloader =\n  /*#__PURE__*/\n  function (_React$Component) {\n    _inherits(Preloader, _React$Component);\n\n    function Preloader() {\n      var _getPrototypeOf2;\n\n      var _this;\n\n      _classCallCheck(this, Preloader);\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Preloader)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleClick\", function (event) {\n        event.preventDefault();\n\n        if (_this.props.onClick) {\n          _this.props.onClick();\n        }\n\n        _this.props.onToggleLoading(true);\n\n        _this.fetchData().then(function () {\n          var _this$props = _this.props,\n              router = _this$props.router,\n              replace = _this$props.replace,\n              to = _this$props.to;\n\n          _this.props.onToggleLoading(false);\n\n          if (replace) {\n            router.replace(replace);\n          } else {\n            router.push(to);\n          }\n        });\n      });\n\n      return _this;\n    }\n\n    _createClass(Preloader, [{\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        if (this.props.immediate) {\n          this.fetchData();\n        }\n      }\n      /**\n       * For a given route, check to see if it has a Relay query attached.\n       *\n       * @example\n       *\n       * Given this link:\n       * <PreloadLink to='/home'>Home</PreloadLink>\n       *\n       * Preloader will iterate over the route config and look for a match and\n       * return its `query` value:\n       *\n       * const routes = [\n       *   {\n       *     path: '/home',\n       *     Component: () => <div>Home!</div>\n       *     query: graphql`\n       *       query routes_HomeQuery {\n       *         ...\n       *       }\n       *     `\n       *   }\n       * ]\n       */\n\n    }, {\n      key: \"getRouteQuery\",\n      value: function getRouteQuery() {\n        var _this$props2 = this.props,\n            _this$props2$system = _this$props2.system,\n            resolver = _this$props2$system.resolver,\n            relayEnvironment = _this$props2$system.relayEnvironment,\n            router = _this$props2.router,\n            to = _this$props2.to;\n        var _Found$ResolverUtils = Found.ResolverUtils,\n            getRouteMatches = _Found$ResolverUtils.getRouteMatches,\n            getRouteValues = _Found$ResolverUtils.getRouteValues;\n        var location = router.createLocation(to);\n        var match = router.matcher.match(location); // Route is missing query, just pass through\n\n        if (!match) {\n          return;\n        }\n\n        var routes = router.matcher.getRoutes(match);\n\n        var augmentedMatch = _objectSpread({}, match, {\n          routes: routes\n        });\n\n        var routeMatches = getRouteMatches(augmentedMatch); // FIXME: This should result in a GraphQLTaggedNode type\n\n        var query = (0, _last2.default)(getRouteValues(routeMatches, function (route) {\n          return route.getQuery;\n        }, function (route) {\n          return route.query;\n        }).filter(function (q) {\n          return !(0, _isUndefined2.default)(q);\n        }));\n        var cacheConfig = (0, _last2.default)(getRouteValues(routeMatches, function (route) {\n          return route.getCacheConfig;\n        }, function (route) {\n          return route.cacheConfig;\n        }).filter(function (caches) {\n          return !(0, _isUndefined2.default)(caches);\n        }));\n        var variables = (0, _last2.default)(resolver.getRouteVariables(match, routeMatches).filter(function (routeVariables) {\n          return !(0, _isUndefined2.default)(routeVariables) && !(0, _isEmpty2.default)(routeVariables);\n        }));\n        return {\n          environment: relayEnvironment,\n          query: query,\n          cacheConfig: cacheConfig,\n          variables: variables\n        };\n      }\n    }, {\n      key: \"fetchData\",\n      value: function fetchData() {\n        var _this2 = this;\n\n        return new Promise(\n        /*#__PURE__*/\n        function () {\n          var _ref = _asyncToGenerator(\n          /*#__PURE__*/\n          regeneratorRuntime.mark(function _callee(resolve, reject) {\n            var routeQuery, requirementsMet, environment, query, variables, cacheConfig;\n            return regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    routeQuery = _this2.getRouteQuery();\n                    requirementsMet = routeQuery && routeQuery.environment && routeQuery.query;\n\n                    if (requirementsMet) {\n                      _context.next = 5;\n                      break;\n                    }\n\n                    console.warn(\"Attempting to use PreloadLink but relayEnvironment or \" + \"query is missing.\", _this2.props);\n                    return _context.abrupt(\"return\", resolve());\n\n                  case 5:\n                    environment = routeQuery.environment, query = routeQuery.query, variables = routeQuery.variables, cacheConfig = routeQuery.cacheConfig;\n                    _context.prev = 6;\n                    _context.next = 9;\n                    return (0, _reactRelay.fetchQuery)(environment, query, variables, cacheConfig);\n\n                  case 9:\n                    resolve(); // FIXME: Handle fetch errors\n                    // router.push('/404')\n\n                    _context.next = 15;\n                    break;\n\n                  case 12:\n                    _context.prev = 12;\n                    _context.t0 = _context[\"catch\"](6);\n                    console.error(\"[Reaction Router/PreloadLink]\", _context.t0);\n\n                  case 15:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, _callee, this, [[6, 12]]);\n          }));\n\n          return function (_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }());\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        // Under the hood <Link> desugars to an `<a>` tag. Ensure only whitelisted\n        // props pass through to avoid React warnings.\n        //\n        // FIXME: Not really clear if these indeed should all be passed through\n        var whitelistedProps = (0, _pick2.default)([\"Component\", \"activeClassName\", \"exact\", \"replace\", \"to\"], this.props);\n        return _react.default.createElement(Found.Link, _extends({}, whitelistedProps, {\n          onClick: this.handleClick\n        }), this.props.children);\n      }\n    }]);\n\n    return Preloader;\n  }(_react.default.Component);\n  /**\n   * Subscribe to PreloadLink state\n   */\n\n\n  _defineProperty(Preloader, \"propTypes\", {\n    /**\n     * Load route query data transparently in the background on mount\n     */\n    immediate: _propTypes.default.bool,\n\n    /**\n     * Route to transition to. Uses history.pushState\n     */\n    to: _propTypes.default.string,\n\n    /**\n     * Route to transition to. Uses history.replaceState. Note that `replace`\n     * and `to` are mutually exclusive.\n     */\n    replace: _propTypes.default.string,\n\n    /**\n     * Class to add when the link's to / replace route matches current URL\n     */\n    activeClassName: _propTypes.default.string,\n\n    /**\n     * State handler to toggle fetching\n     */\n    onToggleFetching: _propTypes.default.func.isRequired,\n\n    /**\n     * Injected props from ContextConsumer\n     */\n    system: _propTypes.default.shape({\n      relayEnvironment: _propTypes.default.object.isRequired,\n      routes: _propTypes.default.array.isRequired,\n      resolver: _propTypes.default.object.isRequired\n    }).isRequired\n  });\n\n  _defineProperty(Preloader, \"defaultProps\", {\n    activeClassName: \"active\",\n    immediate: false,\n    onToggleFetching: function onToggleFetching(x) {\n      return x;\n    }\n  });\n\n  return _react.default.createElement(_unstated.Subscribe, {\n    to: [_state.AppState, _state.PreloadLinkState]\n  }, function (app, preloadLink) {\n    return _react.default.createElement(Preloader, _extends({\n      onToggleLoading: preloadLink.toggleLoading,\n      system: app.state.system\n    }, preloadLinkProps));\n  });\n};\n\nvar PreloadLink = (0, Found.withRouter)((0, _Artsy.ContextConsumer)(_PreloadLink));\nexports.PreloadLink = PreloadLink;",{"version":3,"sources":["src/Router/PreloadLink.tsx"],"names":["_PreloadLink","Preloader","event","preventDefault","props","onClick","onToggleLoading","fetchData","then","router","replace","to","push","immediate","system","resolver","relayEnvironment","Found","ResolverUtils","getRouteMatches","getRouteValues","location","createLocation","match","matcher","routes","getRoutes","augmentedMatch","routeMatches","query","route","getQuery","filter","q","cacheConfig","getCacheConfig","caches","variables","getRouteVariables","routeVariables","environment","Promise","resolve","reject","routeQuery","getRouteQuery","requirementsMet","console","warn","error","whitelistedProps","handleClick","children","React","Component","PropTypes","bool","string","activeClassName","onToggleFetching","func","isRequired","shape","object","array","x","AppState","PreloadLinkState","app","preloadLink","toggleLoading","state","preloadLinkProps","PreloadLink"],"mappings":"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","sourceRoot":"/Users/eve/development/reaction","sourcesContent":["import * as Found from \"found\"\nimport { withRouter } from \"found\"\nimport { Link } from \"found\"\nimport { isEmpty, isUndefined, last, pick } from \"lodash/fp\"\nimport PropTypes from \"prop-types\"\nimport React from \"react\"\nimport { fetchQuery } from \"react-relay\"\nimport { QueryRendererProps } from \"react-relay\"\nimport { AppState, PreloadLinkState } from \"Router/state\"\nimport { Subscribe } from \"unstated\"\nimport { ContextConsumer, ContextProps } from \"../Components/Artsy\"\nimport { AppStateContainer } from \"./types\"\n\nexport interface PreloadLinkProps extends AppStateContainer {\n  children?: any\n  exact?: boolean\n  immediate?: boolean\n  onClick?: () => void\n  onToggleLoading?: (isLoading: boolean) => void\n  replace?: string\n  router?: any // TODO, from found\n  to?: string\n}\n\nconst _PreloadLink: React.SFC<\n  PreloadLinkProps & ContextProps & Found.WithRouter\n> = preloadLinkProps => {\n  /**\n   * Create a Preloader wrapper to perform relay fetches and render out a <Link>\n   */\n  class Preloader extends React.Component<PreloadLinkProps> {\n    static propTypes = {\n      /**\n       * Load route query data transparently in the background on mount\n       */\n      immediate: PropTypes.bool,\n\n      /**\n       * Route to transition to. Uses history.pushState\n       */\n      to: PropTypes.string,\n\n      /**\n       * Route to transition to. Uses history.replaceState. Note that `replace`\n       * and `to` are mutually exclusive.\n       */\n      replace: PropTypes.string,\n\n      /**\n       * Class to add when the link's to / replace route matches current URL\n       */\n      activeClassName: PropTypes.string,\n\n      /**\n       * State handler to toggle fetching\n       */\n      onToggleFetching: PropTypes.func.isRequired,\n\n      /**\n       * Injected props from ContextConsumer\n       */\n      system: PropTypes.shape({\n        relayEnvironment: PropTypes.object.isRequired,\n        routes: PropTypes.array.isRequired,\n        resolver: PropTypes.object.isRequired,\n      }).isRequired,\n    }\n\n    static defaultProps = {\n      activeClassName: \"active\",\n      immediate: false,\n      onToggleFetching: x => x,\n    }\n\n    componentDidMount() {\n      if (this.props.immediate) {\n        this.fetchData()\n      }\n    }\n\n    /**\n     * For a given route, check to see if it has a Relay query attached.\n     *\n     * @example\n     *\n     * Given this link:\n     * <PreloadLink to='/home'>Home</PreloadLink>\n     *\n     * Preloader will iterate over the route config and look for a match and\n     * return its `query` value:\n     *\n     * const routes = [\n     *   {\n     *     path: '/home',\n     *     Component: () => <div>Home!</div>\n     *     query: graphql`\n     *       query routes_HomeQuery {\n     *         ...\n     *       }\n     *     `\n     *   }\n     * ]\n     */\n    getRouteQuery(): Partial<QueryRendererProps> {\n      const {\n        system: { resolver, relayEnvironment },\n        router,\n        to,\n      } = this.props\n\n      const { getRouteMatches, getRouteValues } = Found.ResolverUtils\n      const location = router.createLocation(to)\n      const match = router.matcher.match(location)\n\n      // Route is missing query, just pass through\n      if (!match) {\n        return\n      }\n\n      const routes = router.matcher.getRoutes(match)\n      const augmentedMatch = { ...match, routes }\n      const routeMatches = getRouteMatches(augmentedMatch)\n\n      // FIXME: This should result in a GraphQLTaggedNode type\n      const query: any = last(\n        getRouteValues(\n          routeMatches,\n          route => route.getQuery,\n          route => route.query\n        ).filter(q => !isUndefined(q))\n      )\n\n      const cacheConfig = last(\n        getRouteValues(\n          routeMatches,\n          route => route.getCacheConfig,\n          route => route.cacheConfig\n        ).filter(caches => !isUndefined(caches))\n      )\n\n      const variables = last(\n        resolver\n          .getRouteVariables(match, routeMatches)\n          .filter(\n            routeVariables =>\n              !isUndefined(routeVariables) && !isEmpty(routeVariables)\n          )\n      )\n\n      return {\n        environment: relayEnvironment,\n        query,\n        cacheConfig,\n        variables,\n      }\n    }\n\n    fetchData() {\n      return new Promise(async (resolve, reject) => {\n        const routeQuery = this.getRouteQuery()\n        const requirementsMet =\n          routeQuery && routeQuery.environment && routeQuery.query\n\n        if (!requirementsMet) {\n          console.warn(\n            \"Attempting to use PreloadLink but relayEnvironment or \" +\n              \"query is missing.\",\n            this.props\n          )\n          return resolve()\n        }\n\n        const { environment, query, variables, cacheConfig } = routeQuery\n\n        try {\n          await fetchQuery(environment, query, variables, cacheConfig)\n          resolve()\n\n          // FIXME: Handle fetch errors\n          // router.push('/404')\n        } catch (error) {\n          console.error(\"[Reaction Router/PreloadLink]\", error)\n        }\n      })\n    }\n\n    handleClick = event => {\n      event.preventDefault()\n\n      if (this.props.onClick) {\n        this.props.onClick()\n      }\n\n      this.props.onToggleLoading(true)\n      this.fetchData().then(() => {\n        const { router, replace, to } = this.props\n        this.props.onToggleLoading(false)\n\n        if (replace) {\n          router.replace(replace)\n        } else {\n          router.push(to)\n        }\n      })\n    }\n\n    render() {\n      // Under the hood <Link> desugars to an `<a>` tag. Ensure only whitelisted\n      // props pass through to avoid React warnings.\n      //\n      // FIXME: Not really clear if these indeed should all be passed through\n      //        and not all of them are in the public props either.\n      const whitelistedProps: any = pick(\n        [\"Component\", \"activeClassName\", \"exact\", \"replace\", \"to\"],\n        this.props\n      )\n\n      return (\n        <Link {...whitelistedProps} onClick={this.handleClick}>\n          {this.props.children}\n        </Link>\n      )\n    }\n  }\n\n  /**\n   * Subscribe to PreloadLink state\n   */\n  return (\n    <Subscribe to={[AppState, PreloadLinkState]}>\n      {(app: AppState, preloadLink: PreloadLinkState) => {\n        return (\n          <Preloader\n            onToggleLoading={preloadLink.toggleLoading}\n            system={app.state.system}\n            {...preloadLinkProps}\n          />\n        )\n      }}\n    </Subscribe>\n  )\n}\n\nexport const PreloadLink = withRouter(ContextConsumer(_PreloadLink))\n"]}]}