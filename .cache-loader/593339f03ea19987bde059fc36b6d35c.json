{"remainingRequest":"/Users/eve/development/reaction/node_modules/babel-loader/lib/index.js??ref--5-1!/Users/eve/development/reaction/src/Utils/fillwidth.ts","dependencies":[{"path":"/Users/eve/development/reaction/src/Utils/fillwidth.ts","mtime":1526317885000},{"path":"/Users/eve/development/reaction/.babelrc","mtime":1527877289000},{"path":"/Users/eve/development/reaction/node_modules/cache-loader/dist/cjs.js","mtime":1510929699000},{"path":"/Users/eve/development/reaction/node_modules/babel-loader/lib/index.js","mtime":1509489566000}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _lodash = require(\"lodash\");\n\nvar MAX_ITERATIONS = 1000;\n\nvar fillwidthDimensions = function fillwidthDimensions(items, containerWidth) {\n  var gutter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n  var targetHeight = arguments.length > 3 ? arguments[3] : undefined;\n\n  /**\n   * Scales an image object proportionally based on a direction (either -1 or 1)\n   * @param img a dimension object that references an artwork image\n   * @param dir the direction we need to scale an image, either -1 or 1\n   */\n  var resizeHeight = function resizeHeight(img, dir) {\n    img.width += img.width / img.height * dir;\n    img.height += dir;\n  };\n\n  var totalWhitespace = function totalWhitespace() {\n    return (items.length - 1) * gutter;\n  };\n\n  var widthDiff = function widthDiff(dimensions) {\n    var currentWidth = (0, _lodash.reduce)(dimensions, function (sum, img) {\n      return sum + img.width;\n    }, 0);\n    return containerWidth - currentWidth - totalWhitespace();\n  }; // Get initial dimensions based on the targetHeight\n\n\n  var dimensions = items.map(function (item) {\n    var id;\n    var aspectRatio; // Set id and aspectRatio for Relay or publishing\n\n    if (item.node) {\n      id = item.node.__id;\n      aspectRatio = item.node.image.aspect_ratio;\n    } else {\n      id = item.url ? item.url : item.image;\n      aspectRatio = item.width / item.height;\n    }\n\n    return {\n      __id: id,\n      width: targetHeight * aspectRatio,\n      height: targetHeight\n    };\n  }); // If the total width difference is too small or negative we need to scale down. If not, scale up.\n\n  var dir = widthDiff(dimensions) < 1 ? -1 : 1; // Keep looping until we get an acceptable width difference\n\n  var count = 0;\n\n  while (widthDiff(dimensions) <= 1) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = dimensions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var _img = _step.value;\n        resizeHeight(_img, dir);\n\n        if (widthDiff(dimensions) > 1) {\n          break;\n        }\n      } // Seeing as there have been a couple of bugs in this code and there are no proper tests yet, let’s at least make\n      // sure to no longer run into infinite loops.\n\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    count++;\n\n    if (count === MAX_ITERATIONS) {\n      var data = {\n        items: items,\n        containerWidth: containerWidth,\n        gutter: gutter,\n        targetHeight: targetHeight,\n        dir: dir,\n        dimensions: dimensions\n      };\n      console.error(\"Was unable to calculate a filling width for data: \".concat(JSON.stringify(data)));\n      break;\n    }\n  } // Round image dimensions to whole numbers\n\n\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = dimensions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var _img3 = _step2.value;\n      _img3.width = Math.floor(_img3.width);\n      _img3.height = Math.floor(_img3.height);\n\n      if (widthDiff(dimensions) === 0) {\n        break;\n      }\n    } // Voila, sizes for our images\n\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return dimensions;\n};\n\nvar _default = fillwidthDimensions;\nexports.default = _default;",{"version":3,"sources":["src/Utils/fillwidth.ts"],"names":["MAX_ITERATIONS","fillwidthDimensions","items","containerWidth","gutter","targetHeight","resizeHeight","img","dir","width","height","totalWhitespace","length","widthDiff","currentWidth","dimensions","sum","map","id","aspectRatio","item","node","__id","image","aspect_ratio","url","count","data","console","error","JSON","stringify","Math","floor"],"mappings":"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","file":"/Users/eve/development/reaction/src/Utils/fillwidth.ts","sourceRoot":"/Users/eve/development/reaction","sourcesContent":["import { reduce } from \"lodash\"\n\nconst MAX_ITERATIONS = 1000\n\nconst fillwidthDimensions = (\n  items,\n  containerWidth,\n  gutter = 10,\n  targetHeight\n) => {\n  /**\n   * Scales an image object proportionally based on a direction (either -1 or 1)\n   * @param img a dimension object that references an artwork image\n   * @param dir the direction we need to scale an image, either -1 or 1\n   */\n  const resizeHeight = (img, dir) => {\n    img.width += img.width / img.height * dir\n    img.height += dir\n  }\n\n  const totalWhitespace = () => {\n    return (items.length - 1) * gutter\n  }\n\n  const widthDiff = dimensions => {\n    const currentWidth = reduce(\n      dimensions,\n      (sum, img) => {\n        return sum + img.width\n      },\n      0\n    )\n    return containerWidth - currentWidth - totalWhitespace()\n  }\n\n  // Get initial dimensions based on the targetHeight\n  let dimensions = items.map(item => {\n    let id\n    let aspectRatio\n\n    // Set id and aspectRatio for Relay or publishing\n    if (item.node) {\n      id = item.node.__id\n      aspectRatio = item.node.image.aspect_ratio\n    } else {\n      id = item.url ? item.url : item.image\n      aspectRatio = item.width / item.height\n    }\n\n    return {\n      __id: id,\n      width: targetHeight * aspectRatio,\n      height: targetHeight,\n    }\n  })\n\n  // If the total width difference is too small or negative we need to scale down. If not, scale up.\n  let dir = widthDiff(dimensions) < 1 ? -1 : 1\n\n  // Keep looping until we get an acceptable width difference\n  let count = 0\n  while (widthDiff(dimensions) <= 1) {\n    for (let img of dimensions) {\n      resizeHeight(img, dir)\n      if (widthDiff(dimensions) > 1) {\n        break\n      }\n    }\n    // Seeing as there have been a couple of bugs in this code and there are no proper tests yet, let’s at least make\n    // sure to no longer run into infinite loops.\n    count++\n    if (count === MAX_ITERATIONS) {\n      const data = {\n        items,\n        containerWidth,\n        gutter,\n        targetHeight,\n        dir,\n        dimensions,\n      }\n      console.error(\n        `Was unable to calculate a filling width for data: ${JSON.stringify(\n          data\n        )}`\n      )\n      break\n    }\n  }\n\n  // Round image dimensions to whole numbers\n  for (let img of dimensions) {\n    img.width = Math.floor(img.width)\n    img.height = Math.floor(img.height)\n    if (widthDiff(dimensions) === 0) {\n      break\n    }\n  }\n\n  // Voila, sizes for our images\n  return dimensions\n}\n\nexport default fillwidthDimensions\n"]}]}