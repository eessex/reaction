{"remainingRequest":"/Users/eve/development/reaction/node_modules/babel-loader/lib/index.js??ref--6-1!/Users/eve/development/reaction/src/Utils/fillwidth.ts","dependencies":[{"path":"/Users/eve/development/reaction/src/Utils/fillwidth.ts","mtime":1535727457000},{"path":"/Users/eve/development/reaction/.babelrc","mtime":1537112679000},{"path":"/Users/eve/development/reaction/node_modules/cache-loader/dist/cjs.js","mtime":0},{"path":"/Users/eve/development/reaction/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import _reduce from \"lodash/reduce\";\nvar MAX_ITERATIONS = 1000;\n/**\n * Scales an image object proportionally based on a direction (either -1 or 1)\n * @param img a dimension object that references an artwork image\n * @param dir the direction we need to scale an image, either -1 or 1\n */\n\nvar resizeHeight = function resizeHeight(img, dir) {\n  img.width += img.width / img.height * dir;\n  img.height += dir;\n};\n\nvar fillwidthDimensions = function fillwidthDimensions(items, containerWidth) {\n  var gutter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n  var targetHeight = arguments.length > 3 ? arguments[3] : undefined;\n\n  var totalWhitespace = function totalWhitespace() {\n    return (items.length - 1) * gutter;\n  };\n\n  var widthDiff = function widthDiff(dim) {\n    var currentWidth = _reduce(dim, function (sum, img) {\n      return sum + img.width;\n    }, 0);\n\n    return containerWidth - currentWidth - totalWhitespace();\n  }; // Get initial dimensions based on the targetHeight\n\n\n  var dimensions = items.map(function (item) {\n    var id;\n    var aspectRatio; // Set id and aspectRatio for Relay or publishing\n\n    if (item.node) {\n      id = item.node.__id;\n      aspectRatio = item.node.image.aspect_ratio;\n    } else {\n      id = item.url ? item.url : item.image;\n      aspectRatio = item.width / item.height;\n    }\n\n    return {\n      __id: id,\n      width: targetHeight * aspectRatio,\n      height: targetHeight\n    };\n  }); // If the total width difference is too small or negative we need to scale down. If not, scale up.\n\n  var dir = widthDiff(dimensions) < 1 ? -1 : 1; // Keep looping until we get an acceptable width difference\n\n  var count = 0;\n\n  while (widthDiff(dimensions) <= 1) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = dimensions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var img = _step.value;\n        resizeHeight(img, dir);\n\n        if (widthDiff(dimensions) > 1) {\n          break;\n        }\n      } // Seeing as there have been a couple of bugs in this code and there are no proper tests yet, let’s at least make\n      // sure to no longer run into infinite loops.\n\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    count++;\n\n    if (count === MAX_ITERATIONS) {\n      var data = {\n        items: items,\n        containerWidth: containerWidth,\n        gutter: gutter,\n        targetHeight: targetHeight,\n        dir: dir,\n        dimensions: dimensions\n      };\n      console.error(\"Was unable to calculate a filling width for data: \".concat(JSON.stringify(data)));\n      break;\n    }\n  } // Round image dimensions to whole numbers\n\n\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = dimensions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var _img = _step2.value;\n      _img.width = Math.floor(_img.width);\n      _img.height = Math.floor(_img.height);\n\n      if (widthDiff(dimensions) === 0) {\n        break;\n      }\n    } // Voila, sizes for our images\n\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return dimensions;\n};\n\nexport default fillwidthDimensions;",{"version":3,"sources":["/Users/eve/development/reaction/src/Utils/fillwidth.ts"],"names":["MAX_ITERATIONS","resizeHeight","img","dir","width","height","fillwidthDimensions","items","containerWidth","gutter","targetHeight","totalWhitespace","length","widthDiff","dim","currentWidth","sum","dimensions","map","item","id","aspectRatio","node","__id","image","aspect_ratio","url","count","data","console","error","JSON","stringify","Math","floor"],"mappings":"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","sourcesContent":["import { reduce } from \"lodash\"\n\nconst MAX_ITERATIONS = 1000\n\n/**\n * Scales an image object proportionally based on a direction (either -1 or 1)\n * @param img a dimension object that references an artwork image\n * @param dir the direction we need to scale an image, either -1 or 1\n */\nconst resizeHeight = (img, dir) => {\n  img.width += (img.width / img.height) * dir\n  img.height += dir\n}\n\nconst fillwidthDimensions = (\n  items,\n  containerWidth,\n  gutter = 10,\n  targetHeight\n) => {\n  const totalWhitespace = () => {\n    return (items.length - 1) * gutter\n  }\n\n  const widthDiff = dim => {\n    const currentWidth = reduce(\n      dim,\n      (sum, img) => {\n        return sum + img.width\n      },\n      0\n    )\n    return containerWidth - currentWidth - totalWhitespace()\n  }\n\n  // Get initial dimensions based on the targetHeight\n  const dimensions = items.map(item => {\n    let id\n    let aspectRatio\n\n    // Set id and aspectRatio for Relay or publishing\n    if (item.node) {\n      id = item.node.__id\n      aspectRatio = item.node.image.aspect_ratio\n    } else {\n      id = item.url ? item.url : item.image\n      aspectRatio = item.width / item.height\n    }\n\n    return {\n      __id: id,\n      width: targetHeight * aspectRatio,\n      height: targetHeight,\n    }\n  })\n\n  // If the total width difference is too small or negative we need to scale down. If not, scale up.\n  const dir = widthDiff(dimensions) < 1 ? -1 : 1\n\n  // Keep looping until we get an acceptable width difference\n  let count = 0\n  while (widthDiff(dimensions) <= 1) {\n    for (const img of dimensions) {\n      resizeHeight(img, dir)\n      if (widthDiff(dimensions) > 1) {\n        break\n      }\n    }\n    // Seeing as there have been a couple of bugs in this code and there are no proper tests yet, let’s at least make\n    // sure to no longer run into infinite loops.\n    count++\n    if (count === MAX_ITERATIONS) {\n      const data = {\n        items,\n        containerWidth,\n        gutter,\n        targetHeight,\n        dir,\n        dimensions,\n      }\n      console.error(\n        `Was unable to calculate a filling width for data: ${JSON.stringify(\n          data\n        )}`\n      )\n      break\n    }\n  }\n\n  // Round image dimensions to whole numbers\n  for (const img of dimensions) {\n    img.width = Math.floor(img.width)\n    img.height = Math.floor(img.height)\n    if (widthDiff(dimensions) === 0) {\n      break\n    }\n  }\n\n  // Voila, sizes for our images\n  return dimensions\n}\n\nexport default fillwidthDimensions\n"]}]}