{"remainingRequest":"/Users/eve/development/reaction/node_modules/babel-loader/lib/index.js??ref--6-1!/Users/eve/development/reaction/src/Artsy/Router/Components/PreloadLink.tsx","dependencies":[{"path":"/Users/eve/development/reaction/src/Artsy/Router/Components/PreloadLink.tsx","mtime":1535727457000},{"path":"/Users/eve/development/reaction/.babelrc","mtime":1537112679000},{"path":"/Users/eve/development/reaction/node_modules/cache-loader/dist/cjs.js","mtime":0},{"path":"/Users/eve/development/reaction/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import _pick from \"lodash/fp/pick\";\nimport _last from \"lodash/fp/last\";\nimport _isUndefined from \"lodash/fp/isUndefined\";\nimport _isEmpty from \"lodash/fp/isEmpty\";\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { ContextConsumer, withContext } from \"../../SystemContext\";\nimport { Link } from \"found\";\nimport { withRouter } from \"found\";\nimport { ResolverUtils } from \"found\";\nimport PropTypes from \"prop-types\";\nimport React from \"react\";\nimport { fetchQuery } from \"react-relay\";\nimport { Container, Subscribe } from \"unstated\";\nexport var PreloadLinkState =\n/*#__PURE__*/\nfunction (_Container) {\n  _inherits(PreloadLinkState, _Container);\n\n  function PreloadLinkState() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, PreloadLinkState);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(PreloadLinkState)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"state\", {\n      isLoading: false\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"toggleLoading\", function (isLoading) {\n      _this.setState({\n        isLoading: isLoading\n      });\n    });\n\n    return _this;\n  }\n\n  return PreloadLinkState;\n}(Container);\n\nvar _PreloadLink = function _PreloadLink(preloadLinkProps) {\n  /**\n   * Create a Preloader wrapper to perform relay fetches and render out a <Link>\n   */\n  var Preloader =\n  /*#__PURE__*/\n  function (_React$Component) {\n    _inherits(Preloader, _React$Component);\n\n    function Preloader() {\n      var _getPrototypeOf3;\n\n      var _this2;\n\n      _classCallCheck(this, Preloader);\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      _this2 = _possibleConstructorReturn(this, (_getPrototypeOf3 = _getPrototypeOf(Preloader)).call.apply(_getPrototypeOf3, [this].concat(args)));\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"handleClick\", function (event) {\n        event.preventDefault();\n\n        if (_this2.props.onClick) {\n          _this2.props.onClick();\n        }\n\n        _this2.props.onToggleLoading(true);\n\n        _this2.fetchData().then(function () {\n          var _this2$props = _this2.props,\n              router = _this2$props.router,\n              replace = _this2$props.replace,\n              to = _this2$props.to;\n\n          _this2.props.onToggleLoading(false);\n\n          if (replace) {\n            router.replace(replace);\n          } else {\n            router.push(to);\n          }\n        });\n      });\n\n      return _this2;\n    }\n\n    _createClass(Preloader, [{\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        if (this.props.immediate) {\n          this.fetchData();\n        }\n      }\n      /**\n       * For a given route, check to see if it has a Relay query attached.\n       *\n       * @example\n       *\n       * Given this link:\n       * <PreloadLink to='/home'>Home</PreloadLink>\n       *\n       * Preloader will iterate over the route config and look for a match and\n       * return its `query` value:\n       *\n       * const routes = [\n       *   {\n       *     path: '/home',\n       *     Component: () => <div>Home!</div>\n       *     query: graphql`\n       *       query routes_HomeQuery {\n       *         ...\n       *       }\n       *     `\n       *   }\n       * ]\n       */\n\n    }, {\n      key: \"getRouteQuery\",\n      value: function getRouteQuery() {\n        var _this$props = this.props,\n            resolver = _this$props.resolver,\n            relayEnvironment = _this$props.relayEnvironment,\n            router = _this$props.router,\n            to = _this$props.to;\n        var getRouteMatches = ResolverUtils.getRouteMatches,\n            getRouteValues = ResolverUtils.getRouteValues;\n        var location = router.createLocation(to);\n        var match = router.matcher.match(location); // Route is missing query, just pass through\n\n        if (!match) {\n          return;\n        }\n\n        var routes = router.matcher.getRoutes(match);\n\n        var augmentedMatch = _objectSpread({}, match, {\n          routes: routes\n        });\n\n        var routeMatches = getRouteMatches(augmentedMatch); // FIXME: This should result in a GraphQLTaggedNode type\n\n        var query = _last(getRouteValues(routeMatches, function (route) {\n          return route.getQuery;\n        }, function (route) {\n          return route.query;\n        }).filter(function (q) {\n          return !_isUndefined(q);\n        }));\n\n        var cacheConfig = _last(getRouteValues(routeMatches, function (route) {\n          return route.getCacheConfig;\n        }, function (route) {\n          return route.cacheConfig;\n        }).filter(function (caches) {\n          return !_isUndefined(caches);\n        }));\n\n        var variables = _last(resolver.getRouteVariables(match, routeMatches).filter(function (routeVariables) {\n          return !_isUndefined(routeVariables) && !_isEmpty(routeVariables);\n        }));\n\n        return {\n          environment: relayEnvironment,\n          query: query,\n          cacheConfig: cacheConfig,\n          variables: variables\n        };\n      }\n    }, {\n      key: \"fetchData\",\n      value: function fetchData() {\n        var _this3 = this;\n\n        return new Promise(\n        /*#__PURE__*/\n        function () {\n          var _ref = _asyncToGenerator(\n          /*#__PURE__*/\n          regeneratorRuntime.mark(function _callee(resolve, reject) {\n            var routeQuery, requirementsMet, environment, query, variables, cacheConfig;\n            return regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    routeQuery = _this3.getRouteQuery();\n                    requirementsMet = routeQuery && routeQuery.environment && routeQuery.query;\n\n                    if (requirementsMet) {\n                      _context.next = 5;\n                      break;\n                    }\n\n                    console.warn(\"Attempting to use PreloadLink but relayEnvironment or \" + \"query is missing.\", _this3.props);\n                    return _context.abrupt(\"return\", resolve());\n\n                  case 5:\n                    environment = routeQuery.environment, query = routeQuery.query, variables = routeQuery.variables, cacheConfig = routeQuery.cacheConfig;\n                    _context.prev = 6;\n                    _context.next = 9;\n                    return fetchQuery(environment, query, variables, cacheConfig);\n\n                  case 9:\n                    resolve(); // FIXME: Handle fetch errors\n                    // router.push('/404')\n\n                    _context.next = 15;\n                    break;\n\n                  case 12:\n                    _context.prev = 12;\n                    _context.t0 = _context[\"catch\"](6);\n                    console.error(\"[Reaction Router/PreloadLink]\", _context.t0);\n\n                  case 15:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, _callee, this, [[6, 12]]);\n          }));\n\n          return function (_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }());\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        // Under the hood <Link> desugars to an `<a>` tag. Ensure only whitelisted\n        // props pass through to avoid React warnings.\n        //\n        // FIXME: Not really clear if these indeed should all be passed through\n        var whitelistedProps = _pick([\"Component\", \"activeClassName\", \"exact\", \"replace\", \"to\"], this.props);\n\n        return React.createElement(Link, _extends({}, whitelistedProps, {\n          onClick: this.handleClick\n        }), this.props.children);\n      }\n    }]);\n\n    return Preloader;\n  }(React.Component);\n  /**\n   * Subscribe to PreloadLink state\n   */\n\n\n  _defineProperty(Preloader, \"propTypes\", {\n    /**\n     * Load route query data transparently in the background on mount\n     */\n    immediate: PropTypes.bool,\n\n    /**\n     * Route to transition to. Uses history.pushState\n     */\n    to: PropTypes.string,\n\n    /**\n     * Route to transition to. Uses history.replaceState. Note that `replace`\n     * and `to` are mutually exclusive.\n     */\n    replace: PropTypes.string,\n\n    /**\n     * Class to add when the link's to / replace route matches current URL\n     */\n    activeClassName: PropTypes.string,\n\n    /**\n     * State handler to toggle fetching\n     */\n    onToggleFetching: PropTypes.func.isRequired,\n\n    /**\n     * Injected props from ContextConsumer\n     */\n    relayEnvironment: PropTypes.object.isRequired,\n    routes: PropTypes.array.isRequired,\n    resolver: PropTypes.object.isRequired\n  });\n\n  _defineProperty(Preloader, \"defaultProps\", {\n    activeClassName: \"active\",\n    immediate: false,\n    onToggleFetching: function onToggleFetching(x) {\n      return x;\n    }\n  });\n\n  return React.createElement(ContextConsumer, null, function (context) {\n    return React.createElement(Subscribe, {\n      to: [PreloadLinkState]\n    }, function (preloadLink) {\n      return React.createElement(Preloader, _extends({\n        onToggleLoading: preloadLink.toggleLoading\n      }, context, preloadLinkProps));\n    });\n  });\n};\n\nexport var PreloadLink = withRouter(withContext(_PreloadLink));",{"version":3,"sources":["/Users/eve/development/reaction/src/Artsy/Router/Components/PreloadLink.tsx"],"names":["ContextConsumer","withContext","Link","withRouter","ResolverUtils","PropTypes","React","fetchQuery","Container","Subscribe","PreloadLinkState","isLoading","setState","_PreloadLink","preloadLinkProps","Preloader","event","preventDefault","props","onClick","onToggleLoading","fetchData","then","router","replace","to","push","immediate","resolver","relayEnvironment","getRouteMatches","getRouteValues","location","createLocation","match","matcher","routes","getRoutes","augmentedMatch","routeMatches","query","route","getQuery","filter","q","cacheConfig","getCacheConfig","caches","variables","getRouteVariables","routeVariables","environment","Promise","resolve","reject","routeQuery","getRouteQuery","requirementsMet","console","warn","error","whitelistedProps","handleClick","children","Component","bool","string","activeClassName","onToggleFetching","func","isRequired","object","array","x","context","preloadLink","toggleLoading","PreloadLink"],"mappings":"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","sourcesContent":["import { ContextConsumer, ContextProps, withContext } from \"Artsy/SystemContext\"\nimport { Link } from \"found\"\nimport { withRouter } from \"found\"\nimport { ResolverUtils, Router, WithRouter } from \"found\"\nimport { isEmpty, isUndefined, last, pick } from \"lodash/fp\"\nimport PropTypes from \"prop-types\"\nimport React from \"react\"\nimport { fetchQuery } from \"react-relay\"\nimport { QueryRendererProps } from \"react-relay\"\nimport { SizeProps } from \"styled-system\"\nimport { Container, Subscribe } from \"unstated\"\n\nexport interface PreloadLinkProps extends ContextProps, WithRouter, SizeProps {\n  children?: JSX.Element | string\n  exact?: boolean\n  immediate?: boolean\n  onClick?: () => void\n  onToggleLoading?: (isLoading: boolean) => void\n  replace?: string\n  router: Router\n  to?: string\n}\n\nexport interface PreloadLinkContainer {\n  isLoading: boolean\n}\n\nexport class PreloadLinkState extends Container<PreloadLinkContainer> {\n  state = {\n    isLoading: false,\n  }\n\n  toggleLoading = isLoading => {\n    this.setState({\n      isLoading,\n    })\n  }\n}\n\nconst _PreloadLink: React.SFC<PreloadLinkProps> = preloadLinkProps => {\n  /**\n   * Create a Preloader wrapper to perform relay fetches and render out a <Link>\n   */\n  class Preloader extends React.Component<PreloadLinkProps> {\n    static propTypes = {\n      /**\n       * Load route query data transparently in the background on mount\n       */\n      immediate: PropTypes.bool,\n\n      /**\n       * Route to transition to. Uses history.pushState\n       */\n      to: PropTypes.string,\n\n      /**\n       * Route to transition to. Uses history.replaceState. Note that `replace`\n       * and `to` are mutually exclusive.\n       */\n      replace: PropTypes.string,\n\n      /**\n       * Class to add when the link's to / replace route matches current URL\n       */\n      activeClassName: PropTypes.string,\n\n      /**\n       * State handler to toggle fetching\n       */\n      onToggleFetching: PropTypes.func.isRequired,\n\n      /**\n       * Injected props from ContextConsumer\n       */\n      relayEnvironment: PropTypes.object.isRequired,\n      routes: PropTypes.array.isRequired,\n      resolver: PropTypes.object.isRequired,\n    }\n\n    static defaultProps = {\n      activeClassName: \"active\",\n      immediate: false,\n      onToggleFetching: x => x,\n    }\n\n    componentDidMount() {\n      if (this.props.immediate) {\n        this.fetchData()\n      }\n    }\n\n    /**\n     * For a given route, check to see if it has a Relay query attached.\n     *\n     * @example\n     *\n     * Given this link:\n     * <PreloadLink to='/home'>Home</PreloadLink>\n     *\n     * Preloader will iterate over the route config and look for a match and\n     * return its `query` value:\n     *\n     * const routes = [\n     *   {\n     *     path: '/home',\n     *     Component: () => <div>Home!</div>\n     *     query: graphql`\n     *       query routes_HomeQuery {\n     *         ...\n     *       }\n     *     `\n     *   }\n     * ]\n     */\n    getRouteQuery(): Partial<QueryRendererProps> {\n      const { resolver, relayEnvironment, router, to } = this.props\n      const { getRouteMatches, getRouteValues } = ResolverUtils\n      const location = router.createLocation(to)\n      const match = router.matcher.match(location)\n\n      // Route is missing query, just pass through\n      if (!match) {\n        return\n      }\n\n      const routes = router.matcher.getRoutes(match)\n      const augmentedMatch = { ...match, routes }\n      const routeMatches = getRouteMatches(augmentedMatch)\n\n      // FIXME: This should result in a GraphQLTaggedNode type\n      const query: any = last(\n        getRouteValues(\n          routeMatches,\n          route => route.getQuery,\n          route => route.query\n        ).filter(q => !isUndefined(q))\n      )\n\n      const cacheConfig = last(\n        getRouteValues(\n          routeMatches,\n          route => route.getCacheConfig,\n          route => route.cacheConfig\n        ).filter(caches => !isUndefined(caches))\n      )\n\n      const variables = last(\n        resolver\n          .getRouteVariables(match, routeMatches)\n          .filter(\n            routeVariables =>\n              !isUndefined(routeVariables) && !isEmpty(routeVariables)\n          )\n      )\n\n      return {\n        environment: relayEnvironment,\n        query,\n        cacheConfig,\n        variables,\n      }\n    }\n\n    fetchData() {\n      return new Promise(async (resolve, reject) => {\n        const routeQuery = this.getRouteQuery()\n        const requirementsMet =\n          routeQuery && routeQuery.environment && routeQuery.query\n\n        if (!requirementsMet) {\n          console.warn(\n            \"Attempting to use PreloadLink but relayEnvironment or \" +\n              \"query is missing.\",\n            this.props\n          )\n          return resolve()\n        }\n\n        const { environment, query, variables, cacheConfig } = routeQuery\n\n        try {\n          await fetchQuery(environment, query, variables, cacheConfig)\n          resolve()\n\n          // FIXME: Handle fetch errors\n          // router.push('/404')\n        } catch (error) {\n          console.error(\"[Reaction Router/PreloadLink]\", error)\n        }\n      })\n    }\n\n    handleClick = event => {\n      event.preventDefault()\n\n      if (this.props.onClick) {\n        this.props.onClick()\n      }\n\n      this.props.onToggleLoading(true)\n      this.fetchData().then(() => {\n        const { router, replace, to } = this.props\n        this.props.onToggleLoading(false)\n\n        if (replace) {\n          router.replace(replace)\n        } else {\n          router.push(to)\n        }\n      })\n    }\n\n    render() {\n      // Under the hood <Link> desugars to an `<a>` tag. Ensure only whitelisted\n      // props pass through to avoid React warnings.\n      //\n      // FIXME: Not really clear if these indeed should all be passed through\n      //        and not all of them are in the public props either.\n      const whitelistedProps: any = pick(\n        [\"Component\", \"activeClassName\", \"exact\", \"replace\", \"to\"],\n        this.props\n      )\n\n      return (\n        <Link {...whitelistedProps} onClick={this.handleClick}>\n          {this.props.children}\n        </Link>\n      )\n    }\n  }\n\n  /**\n   * Subscribe to PreloadLink state\n   */\n  return (\n    <ContextConsumer>\n      {context => {\n        return (\n          <Subscribe to={[PreloadLinkState]}>\n            {(preloadLink: PreloadLinkState) => {\n              return (\n                <Preloader\n                  onToggleLoading={preloadLink.toggleLoading}\n                  {...context}\n                  {...preloadLinkProps}\n                />\n              )\n            }}\n          </Subscribe>\n        )\n      }}\n    </ContextConsumer>\n  )\n}\n\nexport const PreloadLink = withRouter(withContext(_PreloadLink))\n"]}]}