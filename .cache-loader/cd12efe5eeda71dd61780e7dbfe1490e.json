{"remainingRequest":"/Users/eve/development/reaction/node_modules/babel-loader/lib/index.js??ref--6-1!/Users/eve/development/reaction/src/Utils/Responsive.tsx","dependencies":[{"path":"/Users/eve/development/reaction/src/Utils/Responsive.tsx","mtime":1533062695000},{"path":"/Users/eve/development/reaction/.babelrc","mtime":1532461619000},{"path":"/Users/eve/development/reaction/node_modules/cache-loader/dist/cjs.js","mtime":0},{"path":"/Users/eve/development/reaction/node_modules/babel-loader/lib/index.js","mtime":1509489566000}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Responsive = exports.ResponsiveProvider = void 0;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar ResponsiveContext = _react.default.createContext({});\n\nvar shallowEqual = function shallowEqual(a, b) {\n  for (var key in a) {\n    if (a[key] !== b[key]) return false;\n  }\n\n  return true;\n}; // TODO: Make this generic on the consumer component when we OSS this separately\n//       and keep this module from where we’ll export our own `Responsive`\n//       wrapper that has these Artsy specific breakpoint typings.\n\n\nvar ResponsiveProvider =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(ResponsiveProvider, _React$Component);\n\n  function ResponsiveProvider(props) {\n    var _this;\n\n    _classCallCheck(this, ResponsiveProvider);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ResponsiveProvider).call(this, props));\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"setupMatchers\", function (breakpoints, breakpointKeys) {\n      return breakpointKeys.map(function (breakpoint) {\n        return window.matchMedia(breakpoints[breakpoint]);\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"checkBreakpoints\", function (breakpoints, breakpointKeys, mediaMatchers) {\n      var nextBreakpoints = breakpoints;\n\n      for (var i = 0; i < mediaMatchers.length; ++i) {\n        nextBreakpoints = _objectSpread({}, nextBreakpoints, _defineProperty({}, breakpointKeys[i], mediaMatchers[i].matches));\n      }\n\n      return nextBreakpoints;\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"breakpointChangedCallback\", function () {\n      _this.setState({\n        breakpoints: _this.checkBreakpoints(_this.state.breakpoints, _this.state.breakpointKeys, _this.state.mediaMatchers)\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"setupObservers\", function () {\n      var _assertThisInitialize = _assertThisInitialized(_assertThisInitialized(_this)),\n          breakpointChangedCallback = _assertThisInitialize.breakpointChangedCallback;\n\n      _this.state.mediaMatchers.forEach(function (mediaQuery) {\n        mediaQuery.addListener(breakpointChangedCallback);\n      });\n    });\n\n    var _breakpointKeys = Object.keys(props.breakpoints); // Build initial breakpoint map --> { breakpoint1: false, breakpoint2: false, ...etc}\n\n\n    var _breakpoints = _breakpointKeys.map(function (breakpoint) {\n      return _defineProperty({}, breakpoint, breakpoint === props.initialBreakpoint ? true : false);\n    }).reduce(function (acc, curr) {\n      return _objectSpread({}, acc, curr);\n    }, {});\n\n    var _mediaMatchers = [];\n    var isClient = typeof window !== \"undefined\";\n\n    if (isClient) {\n      // Build up the MediaQueryList objects that observe mq changes\n      _mediaMatchers = _this.setupMatchers(props.breakpoints, _breakpointKeys); // Perform initial breakpoint check so that first render is correct\n\n      _breakpoints = _this.checkBreakpoints(_breakpoints, _breakpointKeys, _mediaMatchers);\n    }\n\n    _this.state = {\n      breakpoints: _breakpoints,\n      breakpointKeys: _breakpointKeys,\n      mediaMatchers: _mediaMatchers\n    };\n    return _this;\n  }\n  /**\n   * Create an array of media matchers that can validate each breakpoint\n   */\n\n\n  _createClass(ResponsiveProvider, [{\n    key: \"shouldComponentUpdate\",\n    // Lifecycle methods\n    // FIXME: Why doesn’t this get typed automatically?\n    value: function shouldComponentUpdate(nextProps, nextState) {\n      if (nextProps.children !== this.props.children) return true;\n\n      if (shallowEqual(this.state.breakpoints, nextState.breakpoints)) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      var _this2 = this;\n\n      this.state.mediaMatchers.forEach(function (mediaQuery) {\n        return mediaQuery.removeListener(_this2.breakpointChangedCallback);\n      });\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.setupObservers();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return _react.default.createElement(ResponsiveContext.Provider, {\n        value: this.state.breakpoints\n      }, this.props.children);\n    }\n  }]);\n\n  return ResponsiveProvider;\n}(_react.default.Component);\n\nexports.ResponsiveProvider = ResponsiveProvider;\nvar Responsive = ResponsiveContext.Consumer;\nexports.Responsive = Responsive;",{"version":3,"sources":["src/Utils/Responsive.tsx"],"names":["ResponsiveContext","React","createContext","shallowEqual","a","b","key","ResponsiveProvider","props","breakpoints","breakpointKeys","map","window","matchMedia","breakpoint","mediaMatchers","nextBreakpoints","i","length","matches","setState","checkBreakpoints","state","breakpointChangedCallback","forEach","mediaQuery","addListener","Object","keys","initialBreakpoint","reduce","acc","curr","isClient","setupMatchers","nextProps","nextState","children","removeListener","setupObservers","Component","Responsive","Consumer"],"mappings":"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","sourceRoot":"/Users/eve/development/reaction","sourcesContent":["import React from \"react\"\n\nconst ResponsiveContext = React.createContext({})\n\nconst shallowEqual = (a, b) => {\n  for (let key in a) {\n    if (a[key] !== b[key]) return false\n  }\n  return true\n}\n\n// TODO: Make this generic on the consumer component when we OSS this separately\n//       and keep this module from where we’ll export our own `Responsive`\n//       wrapper that has these Artsy specific breakpoint typings.\nexport type Breakpoint = \"xs\" | \"sm\" | \"md\" | \"lg\" | \"xl\"\ntype Breakpoints<T> = { [K in Breakpoint]: T }\n\ntype BreakpointKeys = Breakpoint[]\ntype BreakpointsProp = Breakpoints<string>\ntype BreakpointState = Breakpoints<boolean>\n\nexport interface ResponsiveProviderProps {\n  initialBreakpoint?: Breakpoint\n  breakpoints: BreakpointsProp\n}\n\nexport interface ResponsiveProviderState {\n  breakpoints: BreakpointState\n  breakpointKeys: BreakpointKeys\n  mediaMatchers: MediaQueryList[]\n}\n\nexport class ResponsiveProvider extends React.Component<\n  ResponsiveProviderProps,\n  ResponsiveProviderState\n> {\n  constructor(props: ResponsiveProviderProps) {\n    super(props)\n    const breakpointKeys = Object.keys(props.breakpoints) as BreakpointKeys\n\n    // Build initial breakpoint map --> { breakpoint1: false, breakpoint2: false, ...etc}\n    let breakpoints = breakpointKeys\n      .map(breakpoint => ({\n        [breakpoint]: breakpoint === props.initialBreakpoint ? true : false,\n      }))\n      .reduce((acc, curr) => ({ ...acc, ...curr }), {}) as BreakpointState\n\n    let mediaMatchers = []\n    const isClient = typeof window !== \"undefined\"\n\n    if (isClient) {\n      // Build up the MediaQueryList objects that observe mq changes\n      mediaMatchers = this.setupMatchers(props.breakpoints, breakpointKeys)\n\n      // Perform initial breakpoint check so that first render is correct\n      breakpoints = this.checkBreakpoints(\n        breakpoints,\n        breakpointKeys,\n        mediaMatchers\n      )\n    }\n\n    this.state = {\n      breakpoints,\n      breakpointKeys,\n      mediaMatchers,\n    }\n  }\n\n  /**\n   * Create an array of media matchers that can validate each breakpoint\n   */\n  setupMatchers = (\n    breakpoints: BreakpointsProp,\n    breakpointKeys: BreakpointKeys\n  ): MediaQueryList[] => {\n    return breakpointKeys.map(breakpoint =>\n      window.matchMedia(breakpoints[breakpoint])\n    )\n  }\n\n  /**\n   * Uses the mediaMatchers list to build a map of the states of each breakpoint\n   */\n  checkBreakpoints = (\n    breakpoints: BreakpointState,\n    breakpointKeys: BreakpointKeys,\n    mediaMatchers: MediaQueryList[]\n  ): BreakpointState => {\n    let nextBreakpoints = breakpoints\n    for (let i = 0; i < mediaMatchers.length; ++i) {\n      nextBreakpoints = {\n        ...nextBreakpoints,\n        [breakpointKeys[i]]: mediaMatchers[i].matches,\n      }\n    }\n    return nextBreakpoints\n  }\n\n  /**\n   * The function that will be called any time a breakpoint changes\n   */\n  breakpointChangedCallback = () => {\n    this.setState({\n      breakpoints: this.checkBreakpoints(\n        this.state.breakpoints,\n        this.state.breakpointKeys,\n        this.state.mediaMatchers\n      ),\n    })\n  }\n\n  /**\n   * Creates the event listeners for each breakpoint\n   */\n  setupObservers = () => {\n    const { breakpointChangedCallback } = this\n    this.state.mediaMatchers.forEach(mediaQuery => {\n      mediaQuery.addListener(breakpointChangedCallback)\n    })\n  }\n\n  // Lifecycle methods\n\n  // FIXME: Why doesn’t this get typed automatically?\n  shouldComponentUpdate(\n    nextProps: Readonly<{ children?: React.ReactNode }> &\n      Readonly<ResponsiveProviderProps>,\n    nextState: Readonly<ResponsiveProviderState>\n  ) {\n    if (nextProps.children !== this.props.children) return true\n    if (shallowEqual(this.state.breakpoints, nextState.breakpoints)) {\n      return false\n    }\n    return true\n  }\n\n  componentWillUnmount() {\n    this.state.mediaMatchers.forEach(mediaQuery =>\n      mediaQuery.removeListener(this.breakpointChangedCallback)\n    )\n  }\n\n  componentDidMount() {\n    this.setupObservers()\n  }\n\n  render() {\n    return (\n      <ResponsiveContext.Provider value={this.state.breakpoints}>\n        {this.props.children}\n      </ResponsiveContext.Provider>\n    )\n  }\n}\n\nexport type ResponsiveProps = React.ComponentType<\n  React.ConsumerProps<BreakpointState>\n> & {\n  children?: any\n}\n\nexport const Responsive: ResponsiveProps = ResponsiveContext.Consumer\n"]}]}