{"remainingRequest":"/Users/eve/development/reaction/node_modules/babel-loader/lib/index.js??ref--6-1!/Users/eve/development/reaction/src/Styleguide/Utils/Responsive.tsx","dependencies":[{"path":"/Users/eve/development/reaction/src/Styleguide/Utils/Responsive.tsx","mtime":1530204737000},{"path":"/Users/eve/development/reaction/.babelrc","mtime":1529423546000},{"path":"/Users/eve/development/reaction/node_modules/cache-loader/dist/cjs.js","mtime":0},{"path":"/Users/eve/development/reaction/node_modules/babel-loader/lib/index.js","mtime":1509489566000}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Responsive = exports.ResponsiveProvider = void 0;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nvar ResponsiveContext = _react.default.createContext({});\n\nvar shallowEqual = function shallowEqual(a, b) {\n  for (var key in a) {\n    if (a[key] !== b[key]) return false;\n  }\n\n  return true;\n}; // TODO: Make this generic on the consumer component when we OSS this separately\n//       and keep this module from where we’ll export our own `Responsive`\n//       wrapper that has these Artsy specific breakpoint typings.\n\n\nvar ResponsiveProvider =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(ResponsiveProvider, _React$Component);\n\n  function ResponsiveProvider(props) {\n    var _this;\n\n    _classCallCheck(this, ResponsiveProvider);\n\n    _this = _possibleConstructorReturn(this, (ResponsiveProvider.__proto__ || Object.getPrototypeOf(ResponsiveProvider)).call(this, props));\n\n    _initialiseProps.call(_assertThisInitialized(_this));\n\n    var breakpointKeys = Object.keys(props.breakpoints); // Build initial breakpoint map --> { breakpoint1: false, breakpoint2: false, ...etc}\n\n    var breakpoints = breakpointKeys.map(function (breakpoint) {\n      return _defineProperty({}, breakpoint, breakpoint === props.initialBreakpoint ? true : false);\n    }).reduce(function (acc, curr) {\n      return _extends({}, acc, curr);\n    }, {});\n    var mediaMatchers = [];\n    var isClient = typeof window !== \"undefined\";\n\n    if (isClient) {\n      // Build up the MediaQueryList objects that observe mq changes\n      mediaMatchers = _this.setupMatchers(props.breakpoints, breakpointKeys); // Perform initial breakpoint check so that first render is correct\n\n      breakpoints = _this.checkBreakpoints(breakpoints, breakpointKeys, mediaMatchers);\n    }\n\n    _this.state = {\n      breakpoints: breakpoints,\n      breakpointKeys: breakpointKeys,\n      mediaMatchers: mediaMatchers\n    };\n    return _this;\n  }\n  /**\n   * Create an array of media matchers that can validate each breakpoint\n   */\n\n\n  _createClass(ResponsiveProvider, [{\n    key: \"shouldComponentUpdate\",\n    // Lifecycle methods\n    // FIXME: Why doesn’t this get typed automatically?\n    value: function shouldComponentUpdate(nextProps, nextState) {\n      if (nextProps.children !== this.props.children) return true;\n\n      if (shallowEqual(this.state.breakpoints, nextState.breakpoints)) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      var _this2 = this;\n\n      this.state.mediaMatchers.forEach(function (mediaQuery) {\n        return mediaQuery.removeListener(_this2.breakpointChangedCallback);\n      });\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.setupObservers();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return _react.default.createElement(ResponsiveContext.Provider, {\n        value: this.state.breakpoints\n      }, this.props.children);\n    }\n  }]);\n\n  return ResponsiveProvider;\n}(_react.default.Component);\n\nexports.ResponsiveProvider = ResponsiveProvider;\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this3 = this;\n\n  Object.defineProperty(this, \"setupMatchers\", {\n    configurable: true,\n    enumerable: true,\n    writable: true,\n    value: function value(breakpoints, breakpointKeys) {\n      return breakpointKeys.map(function (breakpoint) {\n        return window.matchMedia(breakpoints[breakpoint]);\n      });\n    }\n  });\n  Object.defineProperty(this, \"checkBreakpoints\", {\n    configurable: true,\n    enumerable: true,\n    writable: true,\n    value: function value(breakpoints, breakpointKeys, mediaMatchers) {\n      var nextBreakpoints = breakpoints;\n\n      for (var i = 0; i < mediaMatchers.length; ++i) {\n        nextBreakpoints = _extends({}, nextBreakpoints, _defineProperty({}, breakpointKeys[i], mediaMatchers[i].matches));\n      }\n\n      return nextBreakpoints;\n    }\n  });\n  Object.defineProperty(this, \"breakpointChangedCallback\", {\n    configurable: true,\n    enumerable: true,\n    writable: true,\n    value: function value() {\n      _this3.setState({\n        breakpoints: _this3.checkBreakpoints(_this3.state.breakpoints, _this3.state.breakpointKeys, _this3.state.mediaMatchers)\n      });\n    }\n  });\n  Object.defineProperty(this, \"setupObservers\", {\n    configurable: true,\n    enumerable: true,\n    writable: true,\n    value: function value() {\n      var breakpointChangedCallback = _this3.breakpointChangedCallback;\n\n      _this3.state.mediaMatchers.forEach(function (mediaQuery) {\n        mediaQuery.addListener(breakpointChangedCallback);\n      });\n    }\n  });\n};\n\nvar Responsive = ResponsiveContext.Consumer;\nexports.Responsive = Responsive;",{"version":3,"sources":["src/Styleguide/Utils/Responsive.tsx"],"names":["ResponsiveContext","createContext","shallowEqual","a","b","key","ResponsiveProvider","props","breakpointKeys","Object","keys","breakpoints","map","breakpoint","initialBreakpoint","reduce","acc","curr","mediaMatchers","isClient","window","setupMatchers","checkBreakpoints","state","nextProps","nextState","children","forEach","mediaQuery","removeListener","breakpointChangedCallback","setupObservers","Component","matchMedia","nextBreakpoints","i","length","matches","setState","addListener","Responsive","Consumer"],"mappings":"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","file":"/Users/eve/development/reaction/src/Styleguide/Utils/Responsive.tsx","sourceRoot":"/Users/eve/development/reaction","sourcesContent":["import React from \"react\"\n\nconst ResponsiveContext = React.createContext({})\n\nconst shallowEqual = (a, b) => {\n  for (let key in a) {\n    if (a[key] !== b[key]) return false\n  }\n  return true\n}\n\n// TODO: Make this generic on the consumer component when we OSS this separately\n//       and keep this module from where we’ll export our own `Responsive`\n//       wrapper that has these Artsy specific breakpoint typings.\nexport type Breakpoint = \"xs\" | \"sm\" | \"md\" | \"lg\" | \"xl\"\ntype Breakpoints<T> = { [K in Breakpoint]: T }\n\ntype BreakpointKeys = Breakpoint[]\ntype BreakpointsProp = Breakpoints<string>\ntype BreakpointState = Breakpoints<boolean>\n\nexport interface ResponsiveProviderProps {\n  initialBreakpoint?: Breakpoint\n  breakpoints: BreakpointsProp\n}\n\nexport interface ResponsiveProviderState {\n  breakpoints: BreakpointState\n  breakpointKeys: BreakpointKeys\n  mediaMatchers: MediaQueryList[]\n}\n\nexport class ResponsiveProvider extends React.Component<\n  ResponsiveProviderProps,\n  ResponsiveProviderState\n> {\n  constructor(props: ResponsiveProviderProps) {\n    super(props)\n    const breakpointKeys = Object.keys(props.breakpoints) as BreakpointKeys\n\n    // Build initial breakpoint map --> { breakpoint1: false, breakpoint2: false, ...etc}\n    let breakpoints = breakpointKeys\n      .map(breakpoint => ({\n        [breakpoint]: breakpoint === props.initialBreakpoint ? true : false,\n      }))\n      .reduce((acc, curr) => ({ ...acc, ...curr }), {}) as BreakpointState\n\n    let mediaMatchers = []\n    const isClient = typeof window !== \"undefined\"\n\n    if (isClient) {\n      // Build up the MediaQueryList objects that observe mq changes\n      mediaMatchers = this.setupMatchers(props.breakpoints, breakpointKeys)\n\n      // Perform initial breakpoint check so that first render is correct\n      breakpoints = this.checkBreakpoints(\n        breakpoints,\n        breakpointKeys,\n        mediaMatchers\n      )\n    }\n\n    this.state = {\n      breakpoints,\n      breakpointKeys,\n      mediaMatchers,\n    }\n  }\n\n  /**\n   * Create an array of media matchers that can validate each breakpoint\n   */\n  setupMatchers = (\n    breakpoints: BreakpointsProp,\n    breakpointKeys: BreakpointKeys\n  ): MediaQueryList[] => {\n    return breakpointKeys.map(breakpoint =>\n      window.matchMedia(breakpoints[breakpoint])\n    )\n  }\n\n  /**\n   * Uses the mediaMatchers list to build a map of the states of each breakpoint\n   */\n  checkBreakpoints = (\n    breakpoints: BreakpointState,\n    breakpointKeys: BreakpointKeys,\n    mediaMatchers: MediaQueryList[]\n  ): BreakpointState => {\n    let nextBreakpoints = breakpoints\n    for (let i = 0; i < mediaMatchers.length; ++i) {\n      nextBreakpoints = {\n        ...nextBreakpoints,\n        [breakpointKeys[i]]: mediaMatchers[i].matches,\n      }\n    }\n    return nextBreakpoints\n  }\n\n  /**\n   * The function that will be called any time a breakpoint changes\n   */\n  breakpointChangedCallback = () => {\n    this.setState({\n      breakpoints: this.checkBreakpoints(\n        this.state.breakpoints,\n        this.state.breakpointKeys,\n        this.state.mediaMatchers\n      ),\n    })\n  }\n\n  /**\n   * Creates the event listeners for each breakpoint\n   */\n  setupObservers = () => {\n    const { breakpointChangedCallback } = this\n    this.state.mediaMatchers.forEach(mediaQuery => {\n      mediaQuery.addListener(breakpointChangedCallback)\n    })\n  }\n\n  // Lifecycle methods\n\n  // FIXME: Why doesn’t this get typed automatically?\n  shouldComponentUpdate(\n    nextProps: Readonly<{ children?: React.ReactNode }> &\n      Readonly<ResponsiveProviderProps>,\n    nextState: Readonly<ResponsiveProviderState>\n  ) {\n    if (nextProps.children !== this.props.children) return true\n    if (shallowEqual(this.state.breakpoints, nextState.breakpoints)) {\n      return false\n    }\n    return true\n  }\n\n  componentWillUnmount() {\n    this.state.mediaMatchers.forEach(mediaQuery =>\n      mediaQuery.removeListener(this.breakpointChangedCallback)\n    )\n  }\n\n  componentDidMount() {\n    this.setupObservers()\n  }\n\n  render() {\n    return (\n      <ResponsiveContext.Provider value={this.state.breakpoints}>\n        {this.props.children}\n      </ResponsiveContext.Provider>\n    )\n  }\n}\n\nexport const Responsive: React.ComponentType<\n  React.ConsumerProps<BreakpointState>\n> =\n  ResponsiveContext.Consumer\n"]}]}